arrays.ipynb:    "# def generate_secret():\n",
arrays.ipynb:      "b'#!/usr/bin/env python3\\n\\nimport codecs\\nimport string\\nimport sys\\nimport time\\n\\nfrom cryptography.hazmat.backends import default_backend\\nfrom cryptography.hazmat.primitives.hashes import SHA1\\nfrom cryptography.hazmat.primitives.twofactor.totp import TOTP\\n\\n\\nONE_WEEK_IN_SECONDS = 604_800\\n\\n\\ndef generate_secret():\\n    totp = TOTP(\\n        key=codecs.encode(string.ascii_letters, encoding=\"utf-8\"),\\n        length=8,\\n        algorithm=SHA1(),\\n        time_step=ONE_WEEK_IN_SECONDS,\\n        backend=default_backend(),\\n    )\\n    seed = int(time.time())\\n    token = codecs.decode(totp.generate(seed), encoding=\"utf-8\")\\n    return f\"{token}-{seed}\"\\n\\n\\n# there are 2 small bugs below you\\'ll have to fix before proceeding :)\\nif __name__ == \"__main__\":\\n    sys.stdout(\\n        f\"Please go to https://ramp.com/careers and use this secret when \"\\n        f\"you apply: {generate_secret}\\\\n\"\\n    )'\n"
arrays.ipynb:    "    def numOfSubarrays(self, arr: List[int]) -> int:    \n",
arrays.ipynb:    "    def numOfSubarrays(self, arr: List[int]) -> int:    \n",
arrays.ipynb:    "        def helper(i, temp_sum):\n",
arrays.ipynb:    "    def smallestRepunitDivByK(self, k: int) -> int:\n",
arrays.ipynb:    "    def sprialOrder(self, matrix):\n",
arrays.ipynb:    "    def hIndex(self, citations: List[int]) -> int:\n",
arrays.ipynb:    "    def numSubarrayBoundedMax(self, nums: List[int], left: int, right: int) -> int:        \n",
arrays.ipynb:    "    def numSubarrayBoundedMax(self, nums: List[int], left: int, right: int) -> int:        \n",
arrays.ipynb:    "    def lenLongestFibSubseq(self, arr: List[int]) -> int:\n",
arrays.ipynb:    "    def lenLongestFibSubseq(self, arr: List[int]) -> int:\n",
arrays.ipynb:    "    def minAvailableDuration(self, slots1: List[List[int]], slots2: List[List[int]], duration: int) -> List[int]:\n",
arrays.ipynb:    "    def maxProfit(self, nums) # single transaction \n",
arrays.ipynb:    "    def maxSubArray(self, nums: List[int]) -> int:\n",
arrays.ipynb:    "    def maxSubArray(self, nums: List[int]) -> int:\n",
arrays.ipynb:    "    def maxSubArray(self, nums):\n",
arrays.ipynb:    "    def isHappy(self, n):        \n",
arrays.ipynb:    "    def minTimeToVisitAllPoints(self, points):\n",
arrays.ipynb:    "    def insert(self, intervals, newInterval):\n",
arrays.ipynb:    "    def multiply(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n",
arrays.ipynb:    "    def isValidSudoku(self, board: List[List[str]]) -> bool:\n",
arrays.ipynb:    "    def isValidSudoku(self, board: List[List[str]]) -> bool:\n",
arrays.ipynb:    "    def knightDialer(self, n: int) -> int:\n",
arrays.ipynb:    "    def helper(self, paths, idx, curr, cache):\n",
arrays.ipynb:    "    def maxAreaOfIsland(self, grid):\n",
arrays.ipynb:    "        def dfs(j,i):\n",
arrays.ipynb:    "    def generatePalindromes(self, s: str) -> List[str]:\n",
arrays.ipynb:    "        def helper(current):\n",
arrays.ipynb:    "    def frequencySort(self, nums: List[int]) -> List[int]:\n",
arrays.ipynb:    "    def prefixSumsToSuffixSums(prefixSums):\n",
arrays.ipynb:    "    def prefixSumsToSuffixSums(prefixSums):\n",
arrays.ipynb:    "    def maxProduct(self, nums):\n",
arrays.ipynb:    "    def findMedianSortedArrays(self, nums1, nums2):\n",
arrays.ipynb:    "    def subarraysDivByK(self, nums: List[int], k: int) -> int:\n",
arrays.ipynb:    "    def gridIllumination(self, N, lamps, queries):\n",
arrays.ipynb:    "    def isGoodArray(self, nums): # bezouts theorem, pure memorization\n",
arrays.ipynb:    "        def gcd(a,b):\n",
arrays.ipynb:    "    def maxSlidingWindow(self, nums, k):\n",
arrays.ipynb:    "    def trap(self, height):\n",
arrays.ipynb:    "    def trap(self, height):\n",
arrays.ipynb:    "    def employeeFreeTime(self, schedule):\n",
arrays.ipynb:    "    def longestConsecutive(self, nums):\n",
arrays.ipynb:    "    def gameOfLife(self, board): # 0->-1 dead->live, 1->2 live->dead \n",
arrays.ipynb:    "    def numPairsDivisibleBy60(self, time):\n",
arrays.ipynb:    "    def gridIllumination(self, N: int, lamps: List[List[int]], queries: List[List[int]]) -> List[int]:\n",
arrays.ipynb:    "    def gridIllumination(self, N, lamps, queries):\n",
arrays.ipynb:    "    def twoSum(self, nums, target):\n",
arrays.ipynb:    "    def twoSum(self, nums, target):\n",
arrays.ipynb:    "    def threeSum(self, nums):\n",
arrays.ipynb:    "    def lastRemaining(self, n): # elimination game \n",
arrays.ipynb:    "    def moveZeroes(self, nums):\n",
arrays.ipynb:    "    def islandPerimeter(self, grid):\n",
arrays.ipynb:    "    def merge(self, intervals):\n",
arrays.ipynb:    "    def invalidTransactions(self, transactions):\n",
arrays.ipynb:    "    def twoCitySchedCost(self, costs):\n",
arrays.ipynb:    "    def search(self, nums, target): # search in rotated array \n",
arrays.ipynb:    "    def removeDuplicates(self, nums):                \n",
arrays.ipynb:    "    def removeDuplicates(self, nums):    \n",
arrays.ipynb:    "    def removeDuplicates(self, nums):\n",
arrays.ipynb:    "    def canAttendMeetings(self, intervals):\n",
arrays.ipynb:    "    def merge(self, nums1, m, nums2, n):\n",
arrays.ipynb:    "    def maximumProduct(self, nums):\n",
arrays.ipynb:    "    def nextPermutation(self, nums):\n",
arrays.ipynb:    "    def numSquares(self, n):\n",
arrays.ipynb:    "    def sortColors(self, nums):\n",
arrays.ipynb:    "    def sortColors(self, nums):\n",
arrays.ipynb:    "    def sortColors(self, nums):\n",
arrays.ipynb:    "    def leastInterval(self, tasks, n):\n",
arrays.ipynb:    "    def partitionLabels(self, S):\n",
arrays.ipynb:    "    def searchRange(self, nums, target):\n",
arrays.ipynb:    "    def maxKilledEnemies(self, grid):\n",
arrays.ipynb:    "        def dfs(j,i,dir):\n",
arrays.ipynb:    "    def canMeasureWater(self, x, y, z):\n",
arrays.ipynb:    "    def wallsAndGates(self, rooms):\n",
arrays.ipynb:    "    def findTheDistanceValue(self, arr1, arr2, d):\n",
arrays.ipynb:    "    def intervalIntersection(self, A, B):        \n",
arrays.ipynb:    "    def pancakeSort(self, arr):\n",
arrays.ipynb:    "    def updateBoard(self, board: List[List[str]], click: List[int]) -> List[List[str]]:\n",
arrays.ipynb:    "        def count_adjacent_mines(j,i):\n",
arrays.ipynb:    "        def dfs(j,i):\n",
arrays.ipynb:    "    def construct(self, grid):\n",
arrays.ipynb:    "    def sortedSquares(self, nums):\n",
arrays.ipynb:    "    def depthSum(self, nestedList):\n",
arrays.ipynb:    "    def subtractProductAndSum(self, n):\n",
arrays.ipynb:    "    def lastStoneWeight(self, stones):            \n",
arrays.ipynb:    "    def rotatedDigits(self, N):\n",
arrays.ipynb:    "    def longestConsecutive(self, nums):\n",
arrays.ipynb:    "    def isToeplitzMatrix(self, matrix):\n",
arrays.ipynb:    "    def wiggleSort(self, nums):\n",
arrays.ipynb:    "    def numberOfSteps (self, num):\n",
arrays.ipynb:    "    def maximizeSweetness(self, A, K):\n",
arrays.ipynb:    "    def isNStraightHand(self, hand, W):\n",
arrays.ipynb:    "    def maxSumTwoNoOverlap(self, A, L, M): \n",
arrays.ipynb:    "    def missingElement(self, nums, k):\n",
arrays.ipynb:    "    def validateStackSequences(self, pushed, popped):\n",
arrays.ipynb:    "    def countKdivPairs(self, A, K): \n",
arrays.ipynb:    "    def rotate(self, matrix):\n",
arrays.ipynb:    "    def rotate(self, nums, k):\n",
arrays.ipynb:    "    def rotate(self, nums, k):\n",
arrays.ipynb:    "    def rotate(self, nums, k):\n",
arrays.ipynb:    "    def hashMap(queryType, query):\n",
arrays.ipynb:    "    def __init__(self, maxsize=8)\n",
arrays.ipynb:    "    def add(self, k, v):\n",
arrays.ipynb:    "    def partition_labels(S):\n",
arrays.ipynb:    "    def prisonAfterNDays(self, cells, N):\n",
arrays.ipynb:    "    def orangesRotting(self, grid):\n",
arrays.ipynb:    "    def kidsWithCandies(self, candies, extraCandies):\n",
arrays.ipynb:    "def memoryAllocator(a, queries):\n",
arrays.ipynb:    "def memoryAllocator(a, queries):\n",
arrays.ipynb:    "    def __init__(self, size: int):\n",
arrays.ipynb:    "    def next(self, val):\n",
arrays.ipynb:    "    def searchInsert(self, nums, target):\n",
arrays.ipynb:    "    def isPerfectSquare(self, num):\n",
arrays.ipynb:    "    def findMaxConsecutiveOnes(self, nums):\n",
arrays.ipynb:    "    def findNumbers(self, nums):\n",
arrays.ipynb:    "    def duplicateZeros(self, arr):    \n",
arrays.ipynb:    "    def checkIfExist(self, arr):\n",
arrays.ipynb:    "    def validMountainArray(self, A):    \n",
arrays.ipynb:    "    def replaceElements(self, arr):\n",
arrays.ipynb:    "    def sortArrayByParity(self, A):\n",
arrays.ipynb:    "    def heightChecker(self, heights):\n",
arrays.ipynb:    "    def thirdMax(self, nums):        \n",
arrays.ipynb:    "    def findDisappearedNumbers(self, nums):    \n",
arrays.ipynb:    "    def containsDuplicate(self, nums):\n",
arrays.ipynb:    "    def singleNumber(self, nums):\n",
arrays.ipynb:    "    def intersect(self, nums1, nums2):\n",
arrays.ipynb:    "    def intersection(self, nums1, nums2):\n",
arrays.ipynb:    "    def containsNearbyDuplicate(self, nums, k):        \n",
arrays.ipynb:    "    def numJewelsInStones(self, J, S):\n",
arrays.ipynb:    "    def majorityElement(self, nums):\n",
arrays.ipynb:    "    def findUnsortedSubarray(self, nums):\n",
arrays.ipynb:    "    def fizzBuzz(self, n):\n",
arrays.ipynb:    "    def missingNumber(self, nums):        \n",
arrays.ipynb:    "    def mySqrt(self, x):\n",
arrays.ipynb:    "    def plusOne(self, digits):\n",
arrays.ipynb:    "    def numIdenticalPairs(self, nums):\n",
arrays.ipynb:    "    def reconstructQueue(self, people):\n",
arrays.ipynb:    "    def dailyTemperatures(self, temperatures):\n",
arrays.ipynb:    "    def dailyTemperatures(self, temperatures):\n",
arrays.ipynb:    "    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n",
arrays.ipynb:    "    def coinChange(self, coins, amount):\n",
arrays.ipynb:    "    def peakIndexInMountainArray(self, A):\n",
arrays.ipynb:    "    def findPeakElement(self, nums):\n",
arrays.ipynb:    "    def pivotIndex(self, nums):        \n",
arrays.ipynb:    "    def isRectangleOverlap(self, rec1, rec2):\n",
arrays.ipynb:    "    def floodFill(self, image, sr, sc, newColor):\n",
arrays.ipynb:    "        def dfs(i, j):\n",
arrays.ipynb:    "    def merge(self, nums1, m, nums2, n):\n",
arrays.ipynb:    "    def rotate(self, nums, k):\n",
arrays.ipynb:    "    def rotateString(self, A: str, B: str) -> bool: \n",
arrays.ipynb:    "    def productExceptSelf(self, nums):\n",
arrays.ipynb:    "    def productExceptSelf(self, nums):\n",
arrays.ipynb:    "    def findDuplicate(self, nums: List[int]) -> int:\n",
arrays.ipynb:    "    def findDuplicate(self, nums: List[int]) -> int:\n",
arrays.ipynb:    "    def maxArea(self, height):\n",
arrays.ipynb:    "    def wordCount(self, board, word):\n",
arrays.ipynb:    "    def buyAndSellStock(self,prices): \n",
arrays.ipynb:    "    def canBeEqual(self, target, arr):\n",
arrays.ipynb:    "        #def reverse(array):\n",
arrays.ipynb:    "    def maxSatisfied(self, customers, grumpy, X):\n",
arrays.ipynb:    "    def dietPlanPerformance(self, calories, k, lower, upper):\n",
arrays.ipynb:    "    def minWindow(self, search_string, target):\n",
arrays.ipynb:    "def isCryptSolution(crypt, solution):\n",
arrays.ipynb:    "    def findRadius(self, houses, heaters):    \n",
arrays.ipynb:    "    def minSubArrayLen(self, s, nums):  \n",
arrays.ipynb:    "    def runningSum(self, nums):\n",
arrays.ipynb:    "    def __init__(self, nums):\n",
arrays.ipynb:    "    def pick(self, target):\n",
binary_search.ipynb:    "    def search(self, nums, target):\n",
binary_search.ipynb:    "    def findPeakElement(self, nums): \n",
binary_search.ipynb:    "    def findMin(self, nums):\n",
concurrency.ipynb:    "    def __init__(self):\n",
concurrency.ipynb:    "    def get_domain(self, url):\n",
concurrency.ipynb:    "    def crawl(self, startUrl, htmlParser):\n",
concurrency.ipynb:    "    def __init__(self,n):\n",
concurrency.ipynb:    "    def fizz(self, printFizz):\n",
concurrency.ipynb:    "    def buzz(self, printBuzz):\n",
concurrency.ipynb:    "    def fizzbuzz(self, printFizzBuzz):\n",
concurrency.ipynb:    "    def number(self, printFizz): # main orchestrator thread \n",
concurrency.ipynb:    "    def __init__(self, capacity):\n",
concurrency.ipynb:    "    def enqueue(self, element):\n",
concurrency.ipynb:    "    def dequeue(self):\n",
concurrency.ipynb:    "    def size(self):\n",
concurrency.ipynb:    "    def __init__(self, capacity):\n",
concurrency.ipynb:    "    def enqueue(self, element): # add element to queue if not full\n",
concurrency.ipynb:    "    def dequeue(self): # return last element in queue\n",
concurrency.ipynb:    "    def size(self):\n",
concurrency.ipynb:    "    def __init__(self):\n",
concurrency.ipynb:    "    def first(self, printFirst):\n",
concurrency.ipynb:    "    def second(self, printSecond):\n",
concurrency.ipynb:    "    def third(self, printThird):\n",
concurrency.ipynb:    "    def __init__(self):\n",
concurrency.ipynb:    "    def hydrogen(self, releaseHydrogen):\n",
concurrency.ipynb:    "    def oxygen(self, releaseOxygen):\n",
concurrency.ipynb:    "    def __init__(self, n):\n",
concurrency.ipynb:    "    def zero(self, printNumber):\n",
concurrency.ipynb:    "    def even(self, printNumber):\n",
concurrency.ipynb:    "    def odd(self, printNumber):\n",
concurrency.ipynb:    "    def __init__(self,n):\n",
concurrency.ipynb:    "    def foo(self, printFoo):\n",
concurrency.ipynb:    "    def bar(self, printBar):\n",
concurrency.ipynb:    "    def __init__(self):\n",
concurrency.ipynb:    "    def carrArrived(self, carId, roadId, direction, turnGreen, crossCar):\n",
concurrency.ipynb:    "    def __init__(self):\n",
concurrency.ipynb:    "    def wantsToEat(self, left_id, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork):\n",
concurrency.ipynb:    "    def __init__(self):\n",
concurrency.ipynb:    "    def first(self, printFirst):\n",
concurrency.ipynb:    "    def second(self, printSecond):\n",
concurrency.ipynb:    "    def third(self, printThird):\n",
concurrency.ipynb:    "    def __init__(self):\n",
concurrency.ipynb:    "    def first(self, printFirst):\n",
concurrency.ipynb:    "    def second(self, printSecond):\n",
concurrency.ipynb:    "    def third(self, printThird):\n",
concurrency.ipynb:    "    def __init__(self):\n",
concurrency.ipynb:    "    def first(self, printFirst):\n",
concurrency.ipynb:    "    def second(self, printSecond):\n",
concurrency.ipynb:    "    def third(self, printThird):\n",
concurrency.ipynb:    "def fun1():\n",
concurrency.ipynb:    "def fun2():\n",
concurrency.ipynb:    "def fun1():\n",
concurrency.ipynb:    "def fun2():\n",
concurrency.ipynb:    "def hello_world(loop):\n",
concurrency.ipynb:    "def square(n):\n",
concurrency.ipynb:    "def main():\n",
concurrency.ipynb:    "def load_url(url, timeout):\n",
concurrency.ipynb:    "def myqueue(queue):\n",
concurrency.ipynb:    "def increment_global():\n",
concurrency.ipynb:    "def taskofThread(lock):\n",
concurrency.ipynb:    "def main():\n",
concurrency.ipynb:    "    def trap(self, height):\n",
data_structures.ipynb:    "    def __init__(self, capacity):\n",
data_structures.ipynb:    "    def connect(self, a, b):\n",
data_structures.ipynb:    "    def delete(self, key):\n",
data_structures.ipynb:    "    def append(self, key, value):\n",
data_structures.ipynb:    "    def get(self, key):\n",
data_structures.ipynb:    "    def put(self, key, value):\n",
data_structures.ipynb:    "    def __init__(self, data): \n",
data_structures.ipynb:    "    def __init__(self): \n",
data_structures.ipynb:    "    #def __init__(self,head=None): \n",
data_structures.ipynb:    "    def add_data_at_beginning(self,data):\n",
data_structures.ipynb:    "    def add_data_at_end(self, data):\n",
data_structures.ipynb:    "    def add_data_after_middle_node(self, middle_node, data):\n",
data_structures.ipynb:    "    def count_length_of_list(self):            \n",
data_structures.ipynb:    "    def print_list(self):\n",
data_structures.ipynb:    "    def deleteNode(self, data_to_delete):\n",
data_structures.ipynb:    "    def reverseLinkedList(self):\n",
data_structures.ipynb:    "    def __init__(self):\n",
data_structures.ipynb:    "    def push(self, x):\n",
data_structures.ipynb:    "    def pop(self):\n",
data_structures.ipynb:    "    def peek(self):\n",
data_structures.ipynb:    "    def empty(self):\n",
data_structures.ipynb:    "def get_index(key: str):\n",
data_structures.ipynb:    "    def __init__(self, length=4):\n",
data_structures.ipynb:    "    def hash(self, key):\n",
data_structures.ipynb:    "    def add(self, key, value):\n",
data_structures.ipynb:    "    def get(self, key):\n",
data_structures.ipynb:    "    def is_full(self):\n",
data_structures.ipynb:    "    def double(self):\n",
data_structures.ipynb:    "    def __setitem__(self, key, value):\n",
data_structures.ipynb:    "    def __getitem__(self, key):\n",
data_structures.ipynb:    "    def __init__(self, val=0, left=None, right=None):\n",
data_structures.ipynb:    "    def __init__(self, key): \n",
data_structures.ipynb:    "def bubble_sort(array):\n",
data_structures.ipynb:    "def merge(left, right):\n",
data_structures.ipynb:    "def merge_sort(array):\n",
data_structures.ipynb:    "def quicksort(array):\n",
data_structures.ipynb:    "def insertion_sort(array):\n",
data_structures.ipynb:    "def selection_sort(nums):\n",
data_structures.ipynb:    "def heapify(nums, n, i):\n",
data_structures.ipynb:    "def heapSort(nums):\n",
data_structures.ipynb:    "def heapify(nums, heap_size, root_index):\n",
data_structures.ipynb:    "def heap_sort(nums):\n",
data_structures.ipynb:    "    def __init__(self, maxsize): \n",
data_structures.ipynb:    "    def maxHeapify(self, i): \n",
data_structures.ipynb:    "    def maxHeap(self): \n",
data_structures.ipynb:    "    def __init__(self, maxsize): \n",
data_structures.ipynb:    "    def minHeapify(self, i): \n",
data_structures.ipynb:    "    def minHeap(self): \n",
data_structures.ipynb:    "    def insert(self, element): \n",
data_structures.ipynb:    "    def parent(self, i): \n",
data_structures.ipynb:    "    def leftChild(self, i): \n",
data_structures.ipynb:    "    def rightChild(self, i): \n",
data_structures.ipynb:    "    def isLeaf(self, i): \n",
data_structures.ipynb:    "    def swap(self, i, j): \n",
data_structures.ipynb:    "    def print(self): \n",
data_structures.ipynb:    "    def getMinfromMinHeap(self):   \n",
data_structures.ipynb:    "    def getMaxfromMaxHeap(self): \n",
design.ipynb:    "    def __init__(self):\n",
design.ipynb:    "    def __init__(self, sentences, times): # add historical data \n",
design.ipynb:    "    def add(self, sentence, times):\n",
design.ipynb:    "    def dfs(self, node, path, result):\n",
design.ipynb:    "    def search(self):\n",
design.ipynb:    "    def input(self, c):\n",
design.ipynb:    "    def __init__(self, capacity: int):\n",
design.ipynb:    "    def get(self, key: int) -> int:\n",
design.ipynb:    "    def put(self, key: int, value: int) -> None:\n",
design.ipynb:    "    def __init__(self, width: int, height: int, food: List[List[int]]):\n",
design.ipynb:    "    def move(self, direction: str) -> int:\n",
design.ipynb:    "    def getUrls(self, url):\n",
design.ipynb:    "    def crawl(self, startUrl, htmlParser): # single threaded\n",
design.ipynb:    "        def dfs(url, htmlParser):\n",
design.ipynb:    "    def __init__(self, maxNumbers):\n",
design.ipynb:    "    def get(self):\n",
design.ipynb:    "    def check(self, number):\n",
design.ipynb:    "    def release(self, number):\n",
design.ipynb:    "    def __init__(self):\n",
design.ipynb:    "    def addScore(self, playerId, score):\n",
design.ipynb:    "    def reset(self, playerId):\n",
design.ipynb:    "    def top(self, K): # T: O(nlogk)\n",
design.ipynb:    "    def __init__(self):\n",
design.ipynb:    "    def hit(self, timestamp):\n",
design.ipynb:    "    def getHits(self, timestamp):\n",
design.ipynb:    "    def hasShips(self, topRight, bottomLeft):\n",
design.ipynb:    "    def __init__(self, x: int, y: int):\n",
design.ipynb:    "    def countShips(self, sea, topRight, bottomLeft):\n",
design.ipynb:    "        def dfs(bottomLeft, topRight):\n",
design.ipynb:    "    def __init__(self):\n",
design.ipynb:    "    def insert(self, val):\n",
design.ipynb:    "    def remove(self, val):\n",
design.ipynb:    "    def getRandom(self):\n",
design.ipynb:    "    def __init__(self):\n",
design.ipynb:    "    def push(self, x):\n",
design.ipynb:    "    def pop(self):\n",
design.ipynb:    "    def top(self):\n",
design.ipynb:    "    def getMin(self):\n",
design.ipynb:    "    def candyCrush(self, board: List[List[int]]) -> List[List[int]]:\n",
design.ipynb:    "        def look_for_matches():            \n",
design.ipynb:    "        def crush_candy(): \n",
design.ipynb:    "        def drop():\n",
design.ipynb:    "    def __init__(self):\n",
design.ipynb:    "    def checkIn(self, id, stationName, t):\n",
design.ipynb:    "    def checkOut(self, id, stationName, t):\n",
design.ipynb:    "    def getAverageTime(self, startStation, endStation):\n",
design.ipynb:    "    def __init__(self, homepage):\n",
design.ipynb:    "    def visit(self, url): # append new or retrieve existing\n",
design.ipynb:    "    def back(self, steps):\n",
design.ipynb:    "    def forward(self, steps):\n",
design.ipynb:    "    def __init__(self, nums):\n",
design.ipynb:    "    def pick(self, target):\n",
dp.ipynb:    "    def lengthOfLIS(self, nums):\n",
dp.ipynb:    "    def maximalSquare(self, matrix):\n",
dp.ipynb:    "    def uniquePaths(self, m: int, n: int) -> int:\n",
dp.ipynb:    "    def wordBreak(self, s, wordDict):\n",
dp.ipynb:    "    def minPathSum(self, grid):\n",
dp.ipynb:    "    def minPathSum(self, grid: List[List[int]]) -> int:\n",
dp.ipynb:    "    def lastStoneWeightII(self, stones):            \n",
dp.ipynb:    "    def canPartition(self, nums):\n",
dp.ipynb:    "    def coinChange(self, coins, amount):        \n",
dp.ipynb:    "    def change(self, amount, coins):\n",
dp.ipynb:    "    def calculateMinimumHP(self, dungeon):\n",
dp.ipynb:    "    def uniquePathsWithObstacles(self, obstacleGrid):\n",
dp.ipynb:    "    def longestCommonSubsequence(self, text1, text2):\n",
dp.ipynb:    "    def canPartitionKSubsets(self, nums, k):    \n",
dp.ipynb:    "        def dfs(idx):\n",
dp.ipynb:    "    def jump(self, nums):\n",
dp.ipynb:    "    def jump(self, nums):\n",
dp.ipynb:    "    def canJump(self, nums):        \n",
dp.ipynb:    "    def canJump(self, nums: List[int]) -> bool:\n",
dp.ipynb:    "    def numDecodings(self, s):\n",
dp.ipynb:    "    def mincostTickets(self, days, costs):    \n",
dp.ipynb:    "    def findTargetSumWays(self, nums, target):\n",
graphs.ipynb:    "    def findCelebrity(self, n: int) -> int:\n",
graphs.ipynb:    "    def countComponents(self, n, edges):\n",
graphs.ipynb:    "        def find(x): # find top parent\n",
graphs.ipynb:    "        def union(u,v): # connect if not already connected\n",
graphs.ipynb:    "    def countComponents(self, n, edges): \n",
graphs.ipynb:    "        def dfs(u):\n",
graphs.ipynb:    "    def earliestAcq(self, logs, n):\n",
graphs.ipynb:    "        def find(x): # find top parent\n",
graphs.ipynb:    "        def union(u,v): # connect if not already connected\n",
graphs.ipynb:    "    def minCostConnectPoints(self, p: List[List[int]]) -> int:\n",
graphs.ipynb:    "        def find(x):\n",
graphs.ipynb:    "        def union(u,v):\n",
graphs.ipynb:    "    def findCircleNum(self, M): # union find\n",
graphs.ipynb:    "        def find(x):\n",
graphs.ipynb:    "        def union(u,v):\n",
graphs.ipynb:    "    def minCostConnectPoints(self, points):\n",
graphs.ipynb:    "    def minimumCost(self, N, connections):\n",
graphs.ipynb:    "    def findOrder(self, numCourses, prerequisites):\n",
graphs.ipynb:    "    def canFinish(self, numCourses, prerequisites):\n",
graphs.ipynb:    "    def checkIfPrerequisite(self, numCourses, prerequisites, queries):\n",
graphs.ipynb:    "        def dfs(start, end):\n",
graphs.ipynb:    "    def eventualSafeNodes(self, graph):\n",
graphs.ipynb:    "    def minimumSemesters(self, N, relations):\n",
graphs.ipynb:    "    def killProcess(self, pid, ppid, kill):\n",
graphs.ipynb:    "    def canVisitAllRooms(self, rooms):        \n",
graphs.ipynb:    "    def networkDelayTime(self, times, N, K):\n",
graphs.ipynb:    "    def findCheapestPrice(self, n, flights, src, dst, K):\n",
graphs.ipynb:    "    def findCheapestPrice(self, n, flights, src, dst, K):\n",
graphs.ipynb:    "    def minCostToSupplyWater(self, n, wells, pipes):\n",
graphs.ipynb:    "    def minMalwareSpread(self, graph, initial): # remove one infected node, keeps its connections \n",
graphs.ipynb:    "        def dfs(u):\n",
graphs.ipynb:    "    def minMalwareSpread(self, graph, initial): # pt 1 dont understand\n",
graphs.ipynb:    "        def dfs(node, node_removed)\n",
graphs.ipynb:    "    def minMalwareSpread2(self, graph, initial):\n",
graphs.ipynb:    "        def dfs(node, removed_node):\n",
graphs.ipynb:    "    def minMalwareSpread2(self, graph, initial): # remove 1 node and remove its connections \n",
graphs.ipynb:    "        def dfs(u):\n",
graphs.ipynb:    "    def findCircleNum(self, M):\n",
graphs.ipynb:    "        def dfs(node):\n",
graphs.ipynb:    "    def findCircleNum(self, M):\n",
graphs.ipynb:    "        def dfs(u):\n",
graphs.ipynb:    "    def allPathsSourceTarget(self, graph): # dag\n",
graphs.ipynb:    "        def dfs(path, node, target):\n",
graphs.ipynb:    "    def allPathsSourceTarget(self, graph):\n",
graphs.ipynb:    "        def dfs(node, path, target):\n",
graphs.ipynb:    "    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\n",
graphs.ipynb:    "        def dfs(room):\n",
graphs.ipynb:    "    def calcEquation(self, equations, values, queries):\n",
graphs.ipynb:    "        def helper(u, v):\n",
graphs.ipynb:    "    def findItinerary(self, tickets):\n",
graphs.ipynb:    "        def dfs(src):\n",
graphs.ipynb:    "    def getImportance(self, employees, id):\n",
graphs.ipynb:    "    def accountsMerge(self, accounts):\n",
graphs.ipynb:    "        def dfs(i, emails):\n",
graphs.ipynb:    "    def numOfMinutes(self, n, headID, manager, informTime):\n",
graphs.ipynb:    "        def dfs(manager, time):\n",
graphs.ipynb:    "    def openLock(self, deadends, target):\n",
graphs.ipynb:    "    def numOfMinutes(self, n, headID, manager, informTime):\n",
graphs.ipynb:    "    def findJudge(self, N, trust):\n",
graphs.ipynb:    "    def findJudge(self, N, trust):\n",
graphs.ipynb:    "    def gardenNoAdj(self, N, paths):\n",
graphs.ipynb:    "    def findRedundantConnection(self, edges):\n",
graphs.ipynb:    "        def is_connected(u, v): # can we reach v from u\n",
graphs.ipynb:    "    def findRedundantConnection(self, edges):\n",
graphs.ipynb:    "        def find(x):\n",
graphs.ipynb:    "        def union(x,y):\n",
hash_map.ipynb:    "    def __init__(self):\n",
hash_map.ipynb:    "    def shouldPrintMessage(self, timestamp: int, message: str) -> bool:\n",
hash_map.ipynb:    "    def __init__(self):\n",
hash_map.ipynb:    "    def shouldPrintMessage(self, timestamp, message):\n",
hash_map.ipynb:    "    def isAlienSorted(self, words: List[str], order: str) -> bool:\n",
hash_map.ipynb:    "    def subarraySum(self, nums, k):\n",
hash_map.ipynb:    "    def subarraySum(self, nums: List[int], k: int) -> int:\n",
hash_map.ipynb:    "    def findAnagrams(self, s: str, p: str) -> List[int]:\n",
hash_map.ipynb:    "    def getHint(self, secret, guess):\n",
hash_map.ipynb:    "    def readBinaryWatch(self, num):\n",
hash_map.ipynb:    "    def highFive(self, items):        \n",
hash_map.ipynb:    "    def subdomainVisits(self, cpdomains):\n",
heap.ipynb:    "    def topKFrequent(self, nums, k):\n",
heap.ipynb:    "    def minMeetingRooms(self, intervals):\n",
heap.ipynb:    "    def findKthLargest(self, nums, k):  \n",
heap.ipynb:    "    def findKthLargest(self, nums: List[int], k: int) -> int:\n",
heap.ipynb:    "    def kClosest(self, points, k): \n",
heap.ipynb:    "    def reorganizeString(self, S):\n",
heap.ipynb:    "    def kSmallestPairs(self, nums1, nums2, k):\n",
heap.ipynb:    "    def compress(self, chars):\n",
heap.ipynb:    "def heapify(nums, n, i):\n",
heap.ipynb:    "    def heapSort(nums):\n",
heap.ipynb:    "    def __init__(self, maxsize): \n",
heap.ipynb:    "    def parent(self, pos): \n",
heap.ipynb:    "    def leftChild(self, pos): \n",
heap.ipynb:    "    def rightChild(self, pos): \n",
heap.ipynb:    "    def isLeaf(self, pos): \n",
heap.ipynb:    "    def swap(self, fpos, spos): \n",
heap.ipynb:    "    def maxHeapify(self, pos): \n",
heap.ipynb:    "    def insert(self, element): \n",
heap.ipynb:    "    def Print(self): \n",
heap.ipynb:    "    def extractMax(self): \n",
heap.ipynb:    "    def __init__(self, maxsize): \n",
heap.ipynb:    "    def parent(self, pos): \n",
heap.ipynb:    "    def leftChild(self, pos): \n",
heap.ipynb:    "    def rightChild(self, pos): \n",
heap.ipynb:    "    def isLeaf(self, pos): \n",
heap.ipynb:    "    def swap(self, fpos, spos): \n",
heap.ipynb:    "    def minHeapify(self, pos): \n",
heap.ipynb:    "    def insert(self, element): \n",
heap.ipynb:    "    def Print(self): \n",
heap.ipynb:    "    def minHeap(self): \n",
heap.ipynb:    "    def remove(self): \n",
linked_list.ipynb:    "    #def __init__(self, val=0, next=None):\n",
linked_list.ipynb:    "    def __init__(self, x):\n",
linked_list.ipynb:    "    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\n",
linked_list.ipynb:    "    def mergeTwoLists(self, l1, l2):\n",
linked_list.ipynb:    "    def hasCycle(self, head):\n",
linked_list.ipynb:    "    def reverseLinkedList(self, head):\n",
linked_list.ipynb:    "    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n",
linked_list.ipynb:    "    def isPalindrome(self,head):\n",
linked_list.ipynb:    "    def removeNthFromEnd(self, head, n):    \n",
linked_list.ipynb:    "    def detectCycle(self, head):\n",
linked_list.ipynb:    "    def sortList(self, head):        \n",
linked_list.ipynb:    "    def merge(self, l, r):\n",
linked_list.ipynb:    "    def copyRandomList(self, head):\n",
linked_list.ipynb:    "    def addTwoNumbers(self, l1, l2): # start from rev ll\n",
linked_list.ipynb:    "    def addTwoNumbers(self, l1, l2):\n",
linked_list.ipynb:    "    def flatten(self, head):\n",
linked_list.ipynb:    "    def print_list(self):\n",
linked_list.ipynb:    "    def removeKFromList(l, k):  \n",
linked_list.ipynb:    "    def removeElements(self, head, val):\n",
linked_list.ipynb:    "    def oddEvenList(self, head):\n",
linked_list.ipynb:    "    def __init__(self, data): \n",
linked_list.ipynb:    "    def __init__(self): \n",
linked_list.ipynb:    "    def print_list(self):\n",
linked_list.ipynb:    "    def add_data_at_beginning(self,new_data):\n",
linked_list.ipynb:    "    def add_data_at_end(self, new_data):\n",
linked_list.ipynb:    "    def add_data_after_middle_node(self, middle_node, new_data):\n",
linked_list.ipynb:    "    def delete_node(self, data_to_delete):  \n",
linked_list.ipynb:    "    def count_length_of_list(self):            \n",
recursion.ipynb:    "    def wordPatternMatch(self, pattern, s): # words in s match letter in p\n",
recursion.ipynb:    "        def dfs(i, j):\n",
recursion.ipynb:    "    def wordPatternMatch(self, pattern, s):\n",
recursion.ipynb:    "        def dfs(i, j):    \n",
recursion.ipynb:    "    def wordBreak(self, s, wordDict):\n",
recursion.ipynb:    "    def dfs(self, s, wordDict):\n",
recursion.ipynb:    "    def wordBreak(self, s, wordDict):\n",
recursion.ipynb:    "        def dfs(i, path):\n",
recursion.ipynb:    "    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n",
recursion.ipynb:    "        def dfs(s_left):\n",
recursion.ipynb:    "    def wordBreak(self, s, words):        \n",
recursion.ipynb:    "        def dfs(dp, end, path): # dfs from end of word to start \n",
recursion.ipynb:    "    def find_subwords(self, s, word_set):\n",
recursion.ipynb:    "        def dfs(s_remaining, path, word_set):\n",
recursion.ipynb:    "    def generateParenthesis(self, n):\n",
recursion.ipynb:    "        def dfs(n_left_remain, n_right_remain, path):\n",
recursion.ipynb:    "    def generateParenthesis(self, n):\n",
recursion.ipynb:    "        def helper(open_remain, close_remain, current_string):\n",
recursion.ipynb:    "    def wordBreak(self, s, wordDict):\n",
recursion.ipynb:    "        def dfs(s_left):\n",
recursion.ipynb:    "    def letterCombinations(self, digits):\n",
recursion.ipynb:    "        def dfs(digits_left, path):\n",
recursion.ipynb:    "    def letterCombinations(self, digits):\n",
recursion.ipynb:    "        def helper(current_result, digits_remain):\n",
recursion.ipynb:    "    def exist(self, board, word): # word search\n",
recursion.ipynb:    "    def dfs_exist(self, j, i, ny, nx, word_temp, board, visited):\n",
recursion.ipynb:    "    def rob(self, nums):\n",
recursion.ipynb:    "   def rob(self, nums: List[int]) -> int:\n",
recursion.ipynb:    "    def getFactors(self, n):\n",
recursion.ipynb:    "    def numIslands2(self, m, n, positions):\n",
recursion.ipynb:    "    def combinationSum(self, nums, target):\n",
recursion.ipynb:    "    def dfs_combinationSum(self, nums, path, target, result, visited):\n",
recursion.ipynb:    "    def combinationSum(self, nums, target):\n",
recursion.ipynb:    "        def dfs_combinationSum(nums, path, target):\n",
recursion.ipynb:    "    def combinationSum3(self, k, n):\n",
recursion.ipynb:    "    def dfs_combinationSum3(self, nums, path, k, n, result, visited):\n",
recursion.ipynb:    "    def combinationSum4(self, nums, target):\n",
recursion.ipynb:    "    def subsetsWithDup(self, nums):\n",
recursion.ipynb:    "    def dfs_subsetsWithDup(self, nums, path, result, visited):\n",
recursion.ipynb:    "    def permuteUnique(self, nums):\n",
recursion.ipynb:    "    def dfs_permuteUnique(self, nums, path, result, visited):\n",
recursion.ipynb:    "    def permute(self, nums: List[int]) -> List[List[int]]:\n",
recursion.ipynb:    "    def dfs_permute(self, nums, path, result):\n",
recursion.ipynb:    "    def subsets(self, nums):\n",
recursion.ipynb:    "    def dfs(self, nums, path):\n",
recursion.ipynb:    "    def combine(self, n, k):\n",
recursion.ipynb:    "    def dfs_combine(self, nums, k, path, result):\n",
recursion.ipynb:    "    def permute(self, nums):\n",
recursion.ipynb:    "    def dfs_permute(self, nums, path, result):\n",
recursion.ipynb:    "    def subsets(self, nums):\n",
recursion.ipynb:    "    def dfs_subsets(self, nums, path, result):\n",
recursion.ipynb:    "    def climbStairs1(self, n):\n",
recursion.ipynb:    "    def climbStairs2(self, n):\n",
recursion.ipynb:    "    def climbStairs3(self, n):\n",
recursion.ipynb:    "    def dfs_canReach(self, arr, i, seen):\n",
recursion.ipynb:    "    def canReach(self, arr, start):\n",
recursion.ipynb:    "    def cleanRoom(self, robot):\n",
recursion.ipynb:    "    def dfs(self, robot, x, y, direction_x, direction_y, visited):\n",
recursion.ipynb:    "    def findContestMatch(self, n):\n",
recursion.ipynb:    "    def reverseString(self, string):\n",
recursion.ipynb:    "    def generate(self, numRows):\n",
recursion.ipynb:    "    def getRow(self, rowIndex):        \n",
recursion.ipynb:    "    def trailingZeroes(self, n):\n",
recursion.ipynb:    "    def isPowerOfThree(self, n): \n",
recursion.ipynb:    "    def fib(self, N):\n",
recursion.ipynb:    "        def recur_fib(N):\n",
recursion.ipynb:    "    def fib3(self, n):\n",
recursion.ipynb:    "    def fib4(self, n):\n",
recursion.ipynb:    "    def balancedStringSplit(self, s):\n",
recursion.ipynb:    "    def readBinaryWatch(self, n_buttons_left):\n",
recursion.ipynb:    "        def dfs(n_buttons_left, hours, mins, idx):\n",
recursion.ipynb:    "    def numSquares(self, n) -> int:    \n",
recursion.ipynb:    "        def dfs(n_squares, difference, squares, combo_min):\n",
recursion.ipynb:    "        def numSquaresRecursive(arr, length, num):\n",
recursion.ipynb:    "    def getKth(self, lo, hi, k):\n",
recursion.ipynb:    "        def calc_power(x, steps):\n",
recursion.ipynb:    "    def maxSumAfterPartitioning(self, A, K):        \n",
recursion.ipynb:    "    def searchMatrix(self, matrix, target):\n",
recursion.ipynb:    "    def searchMatrix(self, matrix, target):\n",
recursion.ipynb:    "        def search(j,i,matrix,target):\n",
recursion.ipynb:    "    def searchMatrix(self, matrix, target):\n",
recursion.ipynb:    "    def numIslands(self, grid):\n",
recursion.ipynb:    "        def mark_visited(i,j):\n",
recursion.ipynb:    "    def numIslands(self, grid):\n",
recursion.ipynb:    "        def mark_visited(j,i):\n",
sorting.ipynb:    "def bubble_sort(array):\n",
sorting.ipynb:    "def insertion_sort(array):\n",
sorting.ipynb:    "def merge(left, right):\n",
sorting.ipynb:    "def merge_sort(array):\n",
sorting.ipynb:    "def quicksort(array):\n",
sorting.ipynb:    "def selection_sort(nums):\n",
sorting.ipynb:    "def heapify(nums, heap_size, root_index):\n",
sorting.ipynb:    "def heap_sort(nums):\n",
strings.ipynb:    "    def removeDuplicateLetters(self, s: str) -> str:\n",
strings.ipynb:    "    def maxDepthAfterSplit(self, seq: str) -> List[int]:\n",
strings.ipynb:    "    def maxDepthAfterSplit(self, s: str) -> List[int]:\n",
strings.ipynb:    "    def longestCommonPrefix(self, strs: List[str]) -> str:\n",
strings.ipynb:    "    def areNumbersAscending(self, s):\n",
strings.ipynb:    "    def generateSentences(self, synonyms: List[List[str]], text: str) -> List[str]:\n",
strings.ipynb:    "        def findSynonym(w):\n",
strings.ipynb:    "            def dfs(u):\n",
strings.ipynb:    "    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n",
strings.ipynb:    "    def placeSpacesBetween(self, words, spaces):\n",
strings.ipynb:    "    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\n",
strings.ipynb:    "    def findNumOfValidWords(self, words, puzzles):\n",
strings.ipynb:    "    def minSteps(self, s, t): # steps to make anagrams \n",
strings.ipynb:    "    def findDuplicate(self, paths):\n",
strings.ipynb:    "    def strStr(self, s, x): # T O(n*m)\n",
strings.ipynb:    "    def wordPattern(self, pattern, s):\n",
strings.ipynb:    "    def firstUniqChar(self, s):\n",
strings.ipynb:    "    def removeDuplicates(self, S): # two in a row \n",
strings.ipynb:    "    def removeDuplicates(self, s, k): # k in a row\n",
strings.ipynb:    "    def lengthOfLongestSubstring(self, s):\n",
strings.ipynb:    "    def isAnagram(self, s, t):        \n",
strings.ipynb:    "    def isValid(self, s):\n",
strings.ipynb:    "    def frequencySort(self, s):\n",
strings.ipynb:    "    def shortestPalindrome(self, s):\n",
strings.ipynb:    "    def decodeString(self, s):\n",
strings.ipynb:    "    def repeatedSubstringPattern(self, s):\n",
strings.ipynb:    "    def reorderLogFiles(self, logs):\n",
strings.ipynb:    "    def fractionToDecimal(self, num, den):\n",
strings.ipynb:    "    def countSubstrings(self, s):\n",
strings.ipynb:    "    def countSubstrings(self, s: str) -> int:\n",
strings.ipynb:    "    def dfs(string_temp, s_left, odd):\n",
strings.ipynb:    "    def generatePalindromes(self, s):\n",
strings.ipynb:    "        def dfs(s_temp):\n",
strings.ipynb:    "    def expand(self, S):\n",
strings.ipynb:    "        def dfs(S, prefix, i):\n",
strings.ipynb:    "    def numUniqueEmails(self, emails):\n",
strings.ipynb:    "    def defangIPaddr(self, address: str) -> str:\n",
strings.ipynb:    "    def findReplaceString(self, S, indexes, sources, targets):\n",
strings.ipynb:    "    def backspaceCompare(self, S, T):\n",
strings.ipynb:    "    def isSubsequence(self, s, t):\n",
strings.ipynb:    "    def prefixStrings(self, a, b): \n",
strings.ipynb:    "    def mostCommonWord(self, paragraph, banned):\n",
strings.ipynb:    "    def longestPalindrome(self, s):        \n",
strings.ipynb:    "        def helper(s, left, right):\n",
strings.ipynb:    "    def numKLenSubstrNoRepeats(self, S, K):\n",
strings.ipynb:    "    def isPalindrome(self, s):\n",
strings.ipynb:    "    def reverseWords(self, s):        \n",
strings.ipynb:    "    def findTheDifference(self, string1, string2):\n",
strings.ipynb:    "    def isIsomorphic(self, s, t):        \n",
strings.ipynb:    "    def findRestaurant(self, list1, list2):\n",
strings.ipynb:    "    def romanToInt(self, s):        \n",
strings.ipynb:    "    def titleToNumber(self, s):        \n",
strings.ipynb:    "    def hammingWeight(self, s): \n",
strings.ipynb:    "    def countAndSay(self, n):\n",
strings.ipynb:    "    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n",
strings.ipynb:    "    def reverseInParentheses(self,s):\n",
strings.ipynb:    "    def amendTheSentence(s):\n",
strings.ipynb:    "    def reverseString(self, s):\n",
strings.ipynb:    "    def reverseString2(self, string):\n",
strings.ipynb:    "    def reverseString3(self, s):\n",
summary.ipynb:    "    def generatePalindromes(self, s: str) -> List[str]:\n",
summary.ipynb:    "        def helper(current):\n",
summary.ipynb:    "    def multiply(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n",
summary.ipynb:    "    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\n",
summary.ipynb:    "    def isValidSudoku(self, board: List[List[str]]) -> bool:\n",
summary.ipynb:    "    def updateBoard(self, board: List[List[str]], click: List[int]) -> List[List[str]]:\n",
summary.ipynb:    "        def count_adjacent_mines(j,i):\n",
summary.ipynb:    "        def dfs(j,i):\n",
trees.ipynb:    "    def __init__(self, val=0, left=None, right=None):\n",
trees.ipynb:    "    def smallestFromLeaf(self, root: TreeNode) -> str:\n",
trees.ipynb:    "        def dfs(node, string):\n",
trees.ipynb:    "    def findTarget(self, root: Optional[TreeNode], k: int) -> bool:\n",
trees.ipynb:    "    def dfs(self, node, cache, k):\n",
trees.ipynb:    "    def findTarget(self, root: Optional[TreeNode], k: int) -> bool:\n",
trees.ipynb:    "    def maxDepth(self, root):\n",
trees.ipynb:    "        def dfs(node, depth):\n",
trees.ipynb:    "    def maxDepth(self, node): \n",
trees.ipynb:    "    def maxDepth(self, root):\n",
trees.ipynb:    "    def maxDepth(self, root):\n",
trees.ipynb:    "    def __init__(self, val=0, left=None, right=None, next=None):\n",
trees.ipynb:    "    def inorderTraversal(self, root):        \n",
trees.ipynb:    "        def helper(node):\n",
trees.ipynb:    "    def inorderTraversal(self, root):\n",
trees.ipynb:    "    def helper(self, node):\n",
trees.ipynb:    "    def inorderTraversal(self, root):\n",
trees.ipynb:    "    def isSymmetric(self, root: TreeNode):\n",
trees.ipynb:    "        def helper(left_node, right_node):\n",
trees.ipynb:    "    def isSymmetric2(self, root):\n",
trees.ipynb:    "    def invertTree(self, root):\n",
trees.ipynb:    "    def diameterOfBinaryTree(self, root):\n",
trees.ipynb:    "        def depth(node):\n",
trees.ipynb:    "    def mergeTrees(self, t1, t2):\n",
trees.ipynb:    "    def numTrees(self, n: int) -> int:\n",
trees.ipynb:    "        def countTrees(n, cache):\n",
trees.ipynb:    "    def numTrees(self, n: int) -> int:\n",
trees.ipynb:    "    def isValidBST(self, root):\n",
trees.ipynb:    "        def helper(node, lower, upper):\n",
trees.ipynb:    "    def levelOrder(self, root):\n",
trees.ipynb:    "    def levelOrder(self, root):\n",
trees.ipynb:    "    def buildTree(self, preorder, inorder):\n",
trees.ipynb:    "    def buildTree(preorder, inorder): # left,root,right; root,left.right\n",
trees.ipynb:    "    def rightSideView(self, root):\n",
trees.ipynb:    "    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n",
trees.ipynb:    "        def helper(node, p, q):\n",
trees.ipynb:    "    def findDistance(self, root: Optional[TreeNode], p: int, q: int) -> int:\n",
trees.ipynb:    "        def dfs(node):\n",
trees.ipynb:    "        def dist(node, target):\n",
trees.ipynb:    "    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\n",
trees.ipynb:    "        def dfs(node, values):\n",
trees.ipynb:    "    def maxPathSum(self, root):\n",
trees.ipynb:    "        def dfs(self, node):\n",
trees.ipynb:    "    def kthSmallest(self, root, k):\n",
trees.ipynb:    "    def levelOrderBottom(self, root):\n",
trees.ipynb:    "    def verticalTraversal(self, root):\n",
trees.ipynb:    "    def verticalOrder(self, root):\n",
trees.ipynb:    "    def connect(self, root): # has missing leafs\n",
trees.ipynb:    "    def connect(self, root): # bfs perfect binary, no missing leafs\n",
trees.ipynb:    "    def connect(self, root): # dfs perfect binary, no missing leafs\n",
trees.ipynb:    "    def dfs(self,node):\n",
trees.ipynb:    "    def __init__(self, val=0, left=None, right=None):\n",
trees.ipynb:    "    def hasPathSum(self, root, sum):        \n",
trees.ipynb:    "    def isSameTree(self, p, q):\n",
trees.ipynb:    "    def zigzagLevelOrder(self, root):\n",
trees.ipynb:    "    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\n",
trees.ipynb:    "    def dfs_bst(self, node, L, R):\n",
trees.ipynb:    "    def printTree(self, root):\n",
trees.ipynb:    "        def get_height(node):\n",
trees.ipynb:    "        def update_output(node, row, left, right):\n",
trees.ipynb:    "    def flipEquiv(self, root1, root2):     \n",
trees.ipynb:    "    def delNodes(self, root, to_delete):\n",
trees.ipynb:    "        def helper(root, is_root):\n",
trees.ipynb:    "    def bstToGst(self, root):\n",
trees.ipynb:    "        def dfs(node):\n",
trees.ipynb:    "    def longestUnivaluePath(self, root):\n",
trees.ipynb:    "        def traverse(node, parent_val):\n",
trees.ipynb:    "    def longestUnivaluePath(self, root):\n",
trees.ipynb:    "    def dfs(self, root):\n",
trees.ipynb:    "    def rob(self, root):\n",
trees.ipynb:    "        def dfs_skip(node, sum_temp):\n",
trees.ipynb:    "    def closestValue(self, root, target):\n",
trees.ipynb:    "    def traverseTree(self, t):\n",
trees.ipynb:    "    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\n",
trees.ipynb:    "    def pathSum(self, root, sum):\n",
trees.ipynb:    "    def dfs(self, root, sum, list_temp, result):\n",
trees.ipynb:    "    def isSameTree(self, p, q):\n",
trees.ipynb:    "    def bfs(visited, root):\n",
trees.ipynb:    "    def minDepthDfs(self, root):\n",
trees.ipynb:    "    def isUnivalTree(self, root):        \n",
trees.ipynb:    "    def searchBST(self, root, val):\n",
trees.ipynb:    "    def searchBST2(self, root, val):\n",
trees.ipynb:    "    def maxDepthDfs(self, root):\n",
trees.ipynb:    "    def maxDepth(self, root):\n",
trees.ipynb:    "    def maxDepth(self, root):\n",
trees.ipynb:    "        def dfs(node, depth):\n",
trees.ipynb:    "    def maxDepth(self.root):\n",
trees.ipynb:    "    def maxDepth(self, root):\n",
trees.ipynb:    "    def helper(self, node, depth):\n",
trees.ipynb:    "    def rob(self, nums):        \n",
trees.ipynb:    "    def sortedArrayToBST(self, nums): \n",
trees.ipynb:    "    def pathSum3(self, root, temp_sum):\n",
trees.ipynb:    "    def maxLevelSum(self, root):            \n",
trees.ipynb:    "    def balanceBST(self, root):\n",
trees.ipynb:    "        def inorder(node):\n",
trees.ipynb:    "        def balance(left, right):\n",
trees.ipynb:    "    def minDepthBfs(self, root):\n",
trees.ipynb:    "    def leafSimilar(self, root1, root2):\n",
trees.ipynb:    "    def isBalanced(self, root):\n",
trees.ipynb:    "    def pathSum3(self, root, sum): \n",
trees.ipynb:    "    def findMode(self, root):\n",
trees.ipynb:    "        def dfs(node):\n",
trees.ipynb:    "    def findMode(self, root):\n",
trees.ipynb:    "    def dfs(self, node, count):\n",
